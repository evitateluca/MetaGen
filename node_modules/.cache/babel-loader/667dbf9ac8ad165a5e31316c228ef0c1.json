{"ast":null,"code":"'use strict';\n\nmodule.exports = lisp;\nlisp.displayName = 'lisp';\nlisp.aliases = [];\n\nfunction lisp(Prism) {\n  ;\n\n  (function (Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n    } // booleans and numbers\n\n\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n\n\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+'; // symbol starting with & used in function arguments\n\n    var marker = '&' + symbol; // Open parenthesis for look-behind\n\n    var par = '(\\\\()';\n    var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n    var space = '(?=\\\\s)';\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [{\n        pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n        lookbehind: true\n      }, {\n        pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n        lookbehind: true\n      }],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [// open paren, brackets, and close paren\n      /(['`,]?\\(|[)\\[\\]])/, // cons\n      {\n        pattern: /(\\s)\\.(?=\\s)/,\n        lookbehind: true\n      }]\n    };\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    };\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    };\n    language['lambda'].inside.arguments = arglist;\n    language['defun'].inside.arguments = Prism.util.clone(arglist);\n    language['defun'].inside.arguments.inside.sublist = arglist;\n    Prism.languages.lisp = language;\n    Prism.languages.elisp = language;\n    Prism.languages.emacs = language;\n    Prism.languages['emacs-lisp'] = language;\n  })(Prism);\n}","map":{"version":3,"names":["module","exports","lisp","displayName","aliases","Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","elisp","emacs"],"sources":["/Applications/MAMP/htdocs/metagen/node_modules/refractor/lang/lisp.js"],"sourcesContent":["'use strict'\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function(Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])')\n    } // booleans and numbers\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])')\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+' // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:for|do|collect|return|finally|append|concat|in|by)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n            symbol +\n            '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n        ),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}